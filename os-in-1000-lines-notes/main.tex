\documentclass[final]{article}
\usepackage[margin=1in]{geometry}
\usepackage{amsmath, amsxtra, verbatim}
\usepackage{amssymb, amsthm}
\usepackage{graphicx}
\graphicspath{./screenshots/}
\usepackage[cmtip,all]{xy}
\usepackage{listings, xcolor}
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolor}{rgb}{0.95,0.95,0.92}
\lstset{
	backgroundcolor=\color{backcolor},
	commentstyle=\color{codegreen},
	keywordstyle=\color{codegray},
	stringstyle=\color{codepurple},
    basicstyle=\ttfamily\small,
    breaklines=true,
	breakatwhitespace=false,
	captionpos=b,
    numbers=left,            % ‚Üê this gives you line numbers
	numbersep=2pt,
	showspaces=false,
	showstringspaces=false,
	showtabs=false,
	tabsize=2
}
\usepackage{url}
\usepackage[notcite, notref]{showkeys}
\usepackage[colorlinks, linkcolor=blue]{hyperref}
\usepackage[
backend=biber,
style=numeric,
sorting=ynt
]{biblatex}
\addbibresource{references.bib}
\usepackage{parskip}

\theoremstyle{definition}
\newtheorem{exercise}{Exercise}
\newtheorem{problem}{Problem}
\newtheorem*{solution}{Solution}
\newtheorem*{definition}{Definition}
\newtheorem{defins}{Definitions}
\newtheorem{example}{Example}
\newtheorem*{remark}{Remark}
\newtheorem*{note}{Note}
\newtheorem*{conjecture}{Conjecture}

\title{OS in 1000 Lines Notes}
\author{Katie Baek}
\date{\today}

\begin{document}

\begin{titlepage}
    \centering
    \vspace*{3cm}
    {\Huge\bfseries OS in 1000 Lines Notes \par}
    \vspace{2cm}
    {\Large Katie Baek\par}
    \vspace{0.3cm}
    {\large Boston College\par}
    \vfill
    % include BC or HAZUS logo?
    \vfill
    {\large \textit{Notes from coding OS in 1000 lines}\par}
    \vspace{0.2cm}
    {\large \today\par} % or replace with a fixed date
\end{titlepage}

\maketitle

\begin{abstract}
	\input{./abstract.tex}
\end{abstract}

\tableofcontents

\section{RISC-V 101}

The chosen CPU for this book is RISC-V, specifically, the 32-bit RISC-V. This is
because there is well-written documentation and it has been rising in popularity
in the recent years. The underlying machine is the QEMU virtual machine.
Although this does not exist in the real world, it's simple and similar to a lot
of real devices.

RISC-V a free and open standard ISA, based on Reduced Instruction Set Computer
principles (designed to simply instructions given to computers to accomplish
tasks). 

\subsection{But what is an ISA?}

The Instruction Set Architecture (ISA) defines the language that the computer
can "think" in (defines its programmable interface):
\begin{enumerate}
	\item Instruction set
	\item Register names and meanings
	\item Calling conventions
	\item Trap/exception behavior
	\item Privilege levels
	\item Memory model
	\item Page table formats
	\item How the system calls work
	\item How interrupts are delivered
\end{enumerate}

A device that interprets instructions defined by an ISA is an implementation of
the ISA. If a devices implements an ISA, then the software that that devices
runs must also comply with that same ISA. A program which was compiled for the
x86 ISA can't necessarily run on the ARM ISA and that is because the way that
they encode instructions are different.

\subsubsection{Why does the OS care about the ISA?}

The ISA is everything to the OS. As stated above, the ISA defines its
programmable interface. The OS must be able to do things like handle traps,
interrupts, and exceptions. It must also set up virtual memory. AKA the OS must
obey the rules of the ISA in order to function.

\subsubsection{How is the ISA different from the ABI?}

First off, what is Application Binary Interface (ABI)? The ABI is sort like a
contract that compiled binaries follow in order to interact with each other
\cite{abi-blog}.
This way, new updates to a kernel or some other program don't break the
functionality of the old ones and things are backwards compatible. Having
knowledge of the ABI isn't necessary to building the OS (I think), but I've ran
into the ABI enough times when researching that it was worth finally writing it
down.

\subsection{RISC-V Assembly}

In order to write an OS, you need to write some assembly. Here is an example of
assembly code:

\begin{lstlisting}
	addi a1 a0 123
\end{lstlisting}

The first instruction \emph{addi} is the instruction name (opcode). The entire
line tells the computer to add the value \textbf{123} to the value \textbf{a1}
and store it in the register \textbf{a0}

\subsection{Registers in RISC-V}

Below is a table of common registers in RISC-V and their given alias that we
will use to refer to them in code.

\begin{table}[ht]
\centering
\begin{tabular}{|l|c|p{5cm}|}
\hline
\textbf{Register} & \textbf{ABI Name (alias)} & \textbf{Description} \\ \hline
\verb|pc| & \verb|pc| & Program counter (where the next instruction is) \\
\hline
\verb|x0| & \verb|zero| & Hardwired zero (always reads as zero) \\ \hline
\verb|x1| & \verb|ra| & Return address \\ \hline
\verb|x2| & \verb|sp| & Stack pointer \\ \hline
\verb|x5-x7| & \verb|t0-t2| & Temporary registers \\ \hline
\verb|x8| & \verb|fp| & Stack frame pointer \\ \hline
\verb|x10-x11| & \verb|a0-a1| & Function arguments/return values \\ \hline
\verb|x12-x17| & \verb|a2-a7| & Function arguments \\ \hline
\verb|x18-x27| & \verb|s0-s11| & Temporary registers saved across calls \\
\hline
\verb|x28-x31| & \verb|t3-t6| & Temporary registers \\ \hline
\end{tabular}
\end{table}

\subsection{Memory access}

Most data is stored in memory, then moved to registers when its needed and so
there are instructions which do this:

\begin{lstlisting}
	lw a0, (a1)
	sw a0, (a1)
\end{lstlisting}

In line 1, you read a word from the address that is stored in \verb|a1|
and store it in \verb|a0|. The equivalent C code is \verb|a0 = *a1|. You are
doing the same thing in line 2, but storing the word instead of
loading it. The \verb|(...)| is like a pointer dereference.


\subsection{Stack}

The stack is a LIFO (last in first out) memory space used for function calls and
local variables. It grows downwards, and the stack pointer, \verb|sp| points to
the "top" of the stack (but functionally the bottom since again, it grows
downwards). To push onto the stack, decrement the stack pointer and store the
value:
\begin{lstlisting}
	addi sp, sp -4 // Move the stack pointer down by 4 bytes
	sw a0, (sp) // Store a0 to the stack
\end{lstlisting}

To pop from the stack, load the value and increment the stack pointer:
\begin{lstlisting}
	lw a0, (sp) // Load a0 from the stack
	addi sp, sp 4 // Move the stack pointer up by 4 bytes
\end{lstlisting}

\subsection{Privileged instructions}

With CPU instructions, there are privileged instructions that applications in
user mode cannot execute. The \textbf{CSR (Control and Status Register)} is a
register that sores CPU settings. We use the following:

\begin{table} [ht]
	\centering
	\begin{tabular}{|p{4cm}|l|}
		\hline
		\textbf{Opcode and operands} & \textbf{Overview} \\ \hline
		\verb|csrr rd, csr| & Read from CSR \\ \hline
		\verb|csrw csr, rs| & Write to CSR \\ \hline
		\verb|csrrw rd, csr, rs| & Read from and write to CSR at once \\ \hline
		\verb|sret| & Return from trap handler \\ \hline
		\verb|sfence.vma| & Clear Translation Lookaside Buffer (TLB) \\ \hline
	\end{tabular}
\end{table}

\subsection{Inline assembly}

Inline assembly code for C looks like this:
\begin{lstlisting}[language=C, caption={sample inline assembly code},
	label={lst: inline assembly}]
	uint32_t value;
	__asm__ __volatile__("csrr %0, sepc" : "=r(value)");
\end{lstlisting}

Where its written in the form of:
\begin{lstlisting} [caption={format of inline assembly code}, label={lst: format
	inline assembly}]
	__asm__ __volatile__("assembly" : output operands : input operands : clobbered registers);
\end{lstlisting}

\begin{table} [ht]
	\centering
	\begin{tabular}{|p{3cm}|p{8cm}|}
		\hline
		\textbf{Part} & \textbf{Description} \\ \hline
		\verb|__asm__| & Indicates its inline assembly \\ \hline
		\verb|__volatile__| & Tell the compiler not to optimize the "assembly"
		code \\ \hline
		\verb|"assembly"| & Assembly code written as a string literal \\ \hline
		output operands & C variables to store the results of the assembly \\
		\hline
		input operands & C expressions to be used in the assembly \\ \hline
		clobbered registers & Registers whose contents are destroyed in the
		assembly. If forgotten, the C compiler won't preserve the contents of
		these registers and would cause a bug. \\ \hline
	\end{tabular}
\end{table}

In the code \ref{lst: inline assembly}, this reads the value of \verb|sepc| CSR
using the \verb|scrr| instruction and assigns it to the \verb|value| variable.

\begin{lstlisting}[caption={different sample inline assembly code}, label={lst:
	different inline assembly}]
	__asm__ __volatile__("csrw sscratch, %0" : : "r"(123))
\end{lstlisting}

In the code \ref{lst: different inline assembly}, this writes \verb|123| to the
\verb|sscratch| CSR, using the \verb|csrw| instruction. The C compiler
automatically sets \verb|123| to the register \verb|a0| so that the assembly can
be executed as written which is nice because then the dev doesn't have to worry
about it.

\section{Overview}

\subsection{Features}

We will implement the following features:
\begin{enumerate}
	\item \textbf{Multitasking}: Switch between processes to allow multiple
		applications to share the CPU
	\item \textbf{Execption Hanlder}: Handle events requiring OS intervention,
		such as illegal instructions
	\item \textbf{Paging}: Provide an isolated memory address space for each
		application
	\item \textbf{System calls}: Allow applications to call kernel features
	\item \textbf{Device drivers}: Abstract hardware functionalities, such as
		disk read/write
	\item \textbf{File system}: Manage files on disk
	\item \textbf{Command-line shell}: User interface for humans
\end{enumerate}


\subsection{QEMU}

\textbf{QEMU} is a machine emulator which can emulate a variety of different
machines. This means that it provides a virtual model of a computer (CPU,
memory, and emulated devices). Since we are writing an OS for the RISC-V ISA, we are using the
machine \verb|virt|. \verb|virt| does not exist in the real world and so it is
only used in virtual machines, but it emulates a 32-bit CPU which implements
the RISC-V ISA along with other devices that could be used in a computer
\cite{virt}.

\subsubsection{So QEMU is not a hypervisor?}

Yes, QEMU is a machine emulator and \emph{not} a hypervisor. A hypervisor is
able to execute instructions on the host CPU. QEMU just emulates the execution
and so it is not a hypervisor. The emulator pretends to be hardware while the
hypervisor lets the guest use the real hardware safely. However, both are
similar in that they allow you to create that virtual machine abstraction.
Within this virtual machine abstraction, we are aiming to develop an OS. This OS
does not know that it's in a VM and it does not know that the machine is being
emulated.

\subsection{QEMU Monitor}

The QEMU monitor is how you can interact with QEMU itself. It is used to:
\begin{enumerate}
	\item Remove or insert removable media images (CD-ROM or floppy disks)
	\item Freeze/unfreeze the VM or save/restore its state from a disk file
	\item Inspect the VM state without an external debugger
\end{enumerate}

\section{Boot}

What happens when the computer is turned on? The CPU initalizes itself and
starts executing the OS. The OS then initalizes the hardware and starts the
applications. This process is called "booting". 

What happens before the OS starts? In PCs, BIOS initalizes the hardware, displays
the splash screen, and loads the OS from the disk. In QEMU virt machine,
\textbf{OpenSBI} is the equivalent of BIOS. This is the CPU "initalizing
itself".

\subsection{Supervisor Binary Interface (SBI)}

The SBI is an API for OS kernels, but defines what the firmware (OpenSBI)
provides to an OS. In QEMU, OpenSBI starts by default, performs
hardware-specific initalization, and boots the kernel. In other words, the SBI
performs tasks on the hardware/controls the hardware on behalf of the OS. It can
be analogous to a program making sys calls to the kernel.

The SBI is specific to RISC-V. It defines how an S-mode operating system (like
the one that we're developing) requests previliged operations from M-mode
firmware. This is a design choice for RISC-V specifically, as, again, it is
based on the \emph{reduced} instruction set computer principles. The S-mode is
the mode in which the kernel operates, M-mode is the mode in which OpenSBI
operates, and the U-mode is the mode in which the user operates. Since the
kernel is in S-mode, it cannot make the privileged calls, where privileged
instructions include things that involve the hardware (like printing to
console). If the kernel wants to make that call, then OpenSBI traps the
instruction, does the printing, then hands control back to the kernel. OpenSBI
is software which complies with the RISC-V SBI and allows the kernel to interact
with the firmware in a standardized manner.

\subsection{Booting OpenSBI}

The following shell code starts OpenSPI:

\begin{lstlisting}[caption={script to start OpenSBI}, label={lst: script-OpenSBI}]
	#!bin/bash
	set -xue

	# QEMU file path
	QEMU=qemu-system-riscv32

	# Start QEMU
	$QEMU -machine virt -bios default -nographic -serial mon:stdio --no-reboot
\end{lstlisting}


With this shell script, you can boot OpenSBI. Specifically, the 
\verb|-bios default| option tells QEMU to use the default firmware, which is OpenSBI. In
addition, at this point, QEMU's standard input and standard output is connected
to the virtual machine's serial port, and the characters that you type in are
being sent to OpenSBI but there is no one to read the characters. This is
because there is literally no OS. In order to do anything, we have to interact
with QEMU (which is the software emulator and a type-2 hypervisor).

Press Ctrl+A then C to switch to the QEMU debug console (QEMU monitor)

Here are the other options which are used in the run script:
\begin{enumerate}
	\item \verb|-machine vert|: Start a \verb|vert| machine
	\item \verb|-bios default|: Use the default firmware (OpenSBI)
	\item \verb|-nographic|: Start QEMU without a GUI window
	\item \verb|-serial mon:stdio|: Connect QEMU's standard IO to the virtual
		machine's serial port. Specifying \verb|mon:| allows switching to the
		QEMU monitor by pressing Ctrl + A then C
	\item \verb|--no-reboot|: If the virtual machine crashes, stop the emulator
		without rebooting (useful for debugging)
\end{enumerate}

\subsection{Linker script}

\lstinputlisting[caption={the linker script}, label={lst: linker
script}]{./code/kernel.ld}

The linker script is a file which defines the memory layout of executable files.
Based on the layout, the linker assigns memory address to functions and
variables. AKA this tells the linker exactly where in memory all parts of the
program should live. You need this because during the \textbf{boot} process,
there is no OS, no loader, and no runtime environment to relocate the code for
you. Specifically, the linker script controls:
\begin{enumerate}
	\item Where the code is placed in memory
	\item Where global variables, stacks, and boot code lives
	\item The address of symbols used by startup code
	\item How the final binary is organized
\end{enumerate}


\subsubsection{Why do you need one during boot?}

When a computer boots, the CPU starts executing from a well-defined hardware
reset address. In this case, it is \verb|0x80200000|. The boot code \emph{must}
be there or else the CPU would start executing whatever is at that address. In
addition, it also defines the variables \verb|__bss|, \verb|__bss_end|, and
\verb|__stack_top| with specific addresses.

The boot code needs to ensure that the hardware is in a state to find and load
the kernel, which is then going to take things over from there \cite{qemu_boot}

\subsection{Minimal kernel}

\lstinputlisting[language=C, caption={kernel code}, label={lst: kernel
code}]{./code/kernel.c}

The kernel starts executing from the \verb|boot| function (which was specified
as the entry point in the linker script). 
\begin{enumerate}
	\item \verb|__attribute__((section(".text.boot")))| controls the placement
		of the function in the linker script. Since OpenSBI jumps to
		\verb|0x80200000| automatically, the boot code needs be to put there
	\item \verb|__attribute__((naked))| instructs the compiler not to generate
		any unnecessary code before and after the function body. This ensures
		that the inline assembly code is the exact function body.
\end{enumerate}

In the \verb|boot| function, in line (24), the \verb|stack pointer (sp)| is set
to the end address of the stack area thats defined in the linker script. Then,
it jumps to the \verb|kernel_main| function.

In line (5), \verb|extern| is used because these variables come from the linker
script, and not \verb|kernel.c|. The \verb|char| and \verb|[]| that they are
addresses, you can take the pointer value of it, and that its type is a pointer
to char, which is a byte.

In the \verb|main| function, the \verb|.bss| section is initalized to zero using
\verb|memset|. Then, the function enters an infinite loop. This prevents the
execution from leaving the controlled code.

\subsection{First kernel debugging}

Because the kernel enters an infinite loop, there are no indications that the
kernel is running correctly. However, you can look at values of registers to see
if anything has gone wrong. To do this, open the QEMU monitor and execute the
\verb|info registers| command

\begin{center}
	\includegraphics[width=5in]{./screenshots/info_registers.png}
\end{center}

\section{Hello World!}

Instead of having to look at registers to confirm whether something is working
or not, want to make it more obvious by printing something to the debug console.

\subsection{Hello via SBI}

To use functions by the SBI, we use the \verb|ecall| function found in line (17)
of Listing \ref{lst: using ecall}. But before that inline assembly code, we have
to ask the compiler to place a few values in specified registers.
Those registers are the ones reserved for the kernel.
That is
accomplished in lines (7) - (14) in Listing \ref{lst: using ecall}.
Specifically, the \verb|register| and \verb|__asm__("register name")| does this.

When \verb|ecall| is evoked, the CPU's execution mode switches from kernel mode
(S-Mode) to OpenSBI mode (M-Mode) and OpenSBI's processing handler is invoked.
Once its finished, it switches back to kernel mode and execution resumes after
the \verb|ecall| instruction.

\smallskip

\lstinputlisting[language=C, caption={(kernel.h) using ecall}, label={lst:
header using ecall}]{./code/kernel_putchar.h}

\smallskip

\lstinputlisting[language=C, caption={(kernel.c) using ecall}, label={lst: using
ecall}]{./code/kernel_putchar.c}

In order to write to the console, need to use the OpenSBI call 
\verb|Console Putchar|, which puts a character to the console. To make the call, we select
function 0 and extension 1 (by putting \( 0 \) in register \verb|a6| and \( 1 \)
in register \verb|a7|) \cite{sbicalls}. In addition, SBI functions must return a
pair of values in \verb|a0| and \verb|a1| where the value in \verb|a0| is the
error code. This is why we have the \verb|struct sbiret| definition in Listing
\ref{lst: header using ecall}. In addition, \verb|Console Putchar| is guarenteed
not to change registers \verb|a2| to \verb|a7|.

\subsection{printf function}

Now, we can implement the \verb|printf| function which, under the hood, simply
prints the characters supplied to the function (using \verb|Console Putchar|).
In this \verb|printf|, we are only going to support 3 format specifiers:
\begin{enumerate}
	\item \verb|%d| (decimal)
	\item \verb|%x| (hexadecimal)
	\item \verb|%s| (string)
\end{enumerate}

\lstinputlisting[language=C, caption={(common.h) header file for printf},
label={lst: header file for printf}]{./code/common_printf.h}

\smallskip

\lstinputlisting[language=C, caption={(common.c) C file for printf}, label={lst:
C file for printf}]{./code/common_printf.c}

\subsubsection{What are the builtin features?}

In Listing \ref{lst: header file for printf}, all of the \verb|define| macros map the
standard variadic-names to compiler intrinsics. The standard variadic names are
typically defined in \verb|<stdarg.h>| and allows functions to accept an
indefinite number of arguments \cite{stdarg}. However, since we're writing our
own kernel, \verb|<stdarg.h>| is not available to use so instead we use Clang's
built-ins.
\begin{enumerate}
	\item \verb|__buildtin_va_list|: represents the internal structure that
		stores the argument pointer
	\item \verb|__builtin_va_start(ap, last)|: initalizes a \verb|va_list| to
		start reading args after the parameter \verb|last|
	\item \verb|__builtin_va_arg(ap, type)|: Fetches the next argument from the
		list and converts it to \verb|type|
	\item \verb|__builtin_va_end(ap)|: cleans up
\end{enumerate}

The arguments need to be \emph{variadic} because \verb|printf| can take any
number of format specifiers. The various \verb|va_...| are used to loop through
the arguments.

\subsubsection{How are the builtin features used in printf?}

Typically, function arguments are stored in registers. Since the number of
arguments is variadic, the arguments are stored in memory, then loaded into the
registers using the \verb|builtin| features.

In Listing \ref{lst: C file for printf}, line (6) declares a variable named
\verb|vargs| of type \verb|va_list|. This stores the current position in the
list of arguments but does not hold anything yet. Line (7) initalizes the
\verb|va_list| so you can read arguments from it. It finds where the variable
arguments begin in the stack/registers, sets \verb|vargs| to point immediately
after \verb|fmt| and prepares \verb|vargs| so that calls to 
\verb|va_arg(vargs,type)| will fetch each additional argument. After each call to
\verb|av_arg(vargs, type)|, \verb|vargs| is automatically incremented to "point"
to the next variable. 

\section{C Standard Library}

\lstinputlisting[language=C, caption={new additions to common.h}, label={lst:
new additions to common.h}] {./code/common_c_stand_lib.h}

A few useful macros (in Listing \ref{lst: new additions to common.h}):
\begin{enumerate}
	\item \verb|paddr_t|: A type representing physical memory address
	\item \verb|vaddr_t|: A type representing virtual memory addresses
	\item \verb|align_up|: Round up \verb|value| to the nearest multiple of
		\verb|align| and \verb|align| must be a power of 2
	\item \verb|is_aligned|: Checks if \verb|value| is a multiple of \verb|align|
	\item \verb|offsetof|: Returns the offset of a member within a structure
		(how many bytes from the start of the structure)
\end{enumerate}

\subsection{Memory operation}


\printbibliography[
heading=bibintoc
]
\end{document}
